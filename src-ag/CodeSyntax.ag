imports
{
import Patterns
import CommonTypes
import Data.Map(Map)
import Data.Set(Set)
import Code(Expr)
}

DATA  CGrammar 
   |  CGrammar  typeSyns  : {TypeSyns}
                derivings : {Derivings} 
                wrappers  : {Set NontermIdent} 
                nonts     : CNonterminals
                pragmas   : {PragmaMap}
                paramMap  : {ParamMap}
                contextMap: {ContextMap}
                aroundsMap: {Map NontermIdent (Map ConstructorIdent (Set Identifier))}

TYPE CNonterminals = [CNonterminal]

DATA  CNonterminal 
   |  CNonterminal nt         :  NontermIdent
                   params     :  {[Identifier]}
                   inh        :  Attributes
                   syn        :  Attributes
                   inhDflt    :  {Map Identifier Expr}
                   prods      :  CProductions
                   inter      :  CInterface

DATA  CInterface
   |  CInterface seg:CSegments

TYPE CSegments = [CSegment]

DATA  CSegment
   |  CSegment  inh  :  Attributes
                syn  :  Attributes

TYPE CProductions = [CProduction]

DATA  CProduction
   |  CProduction   con        : ConstructorIdent
                    visits     : CVisits
                    children   : {[(Identifier,Type,Maybe (Maybe Type))]}
                    terminals  : {[Identifier]}

TYPE CVisits = [CVisit]

DATA  CVisit 
   |  CVisit  inh     :  Attributes
              syn     :  Attributes
              vss     :  CRuleTree  -- sequence of "steps", where each "step" is either an attribute definition or a child visit
              intra   :  Sequence  -- how to glue the visits together (child visits are child-intra's, attr-defs are attr-intra's)
              ordered :  Bool -- indicates that vss is ordered

TYPE CRuleTrees = [CRuleTree]

DATA CRuleTree
  | CTPar xs  : CRuleTrees
  | CTSeq xs  : CRuleTrees
  | CTRule r  : CRule

TYPE Sequence = [CRule]

DATA  CRule
   |  CRule        name       :  Identifier
                   isIn       :  Bool   -- True iff there is a definition for an inherited attribute
                   hasCode    :  Bool   -- True iff there is an RHS
                   nt         :  NontermIdent
                   con        :  ConstructorIdent
                   field      :  Identifier
                   childnt    :  {Maybe NontermIdent}  -- Just n: 'field' of 'nt' and 'con' is a nonterminal 'n', Nothing: it is a terminal
                   tp         :  {Maybe Type}     -- type of the attribute
                   pattern    :  Pattern     -- only defined if 'isIn' is False
                   rhs        :  {[String]}     -- empty string if 'hasCode' is False
                   defines    :  {Map Int (Identifier,Identifier,Maybe Type)}   -- the attributes defined by this rule
                   owrt       :  {Bool}
                   origin     :  String  -- just for documentation (and maybe errors)
                   uses       :  {Set (Identifier, Identifier)}
                   explicit   :  Bool   -- True if this an explicit rule found in the source file
                   mbNamed    : {Maybe Identifier}
                   heavy      : Bool
   |  CChildVisit  name    :  Identifier  -- corresponding to the name of the child
                   nt      :  NontermIdent
                   nr      :  Int   -- visit number
                   inh     :  Attributes
                   syn     :  Attributes
                   isLast  :  Bool  -- indicates whether this is the last visit to this child
                   parCan  :  Bool

SET AllCodeSyntax
  = CGrammar
    CNonterminal CNonterminals
    CInterface CSegments CSegment
    CProduction CProductions
    CVisits CVisit
    CRule
    CRuleTree CRuleTrees

