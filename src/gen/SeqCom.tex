\documentclass[8pt]{report}
%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\begin{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Collecting information}

In the Data.Graph library,
a graph is represented as \ensuremath{\Conid{Array}\;\Conid{Vertex}\;[\mskip1.5mu \Conid{Vertex}\mskip1.5mu]},
mapping each vertex to a list of adjacent vertices.
A \ensuremath{\Conid{Vertex}} is simply encoded by an \ensuremath{\Conid{Int}}.
So to test whether an edge \ensuremath{(\Varid{x},\Varid{y})} belongs to \ensuremath{\Varid{g}}
we can evaluate \ensuremath{\Varid{y}\in \Varid{g}\mathbin{!}\Varid{x}}

For more efficiency, we use Maps instead of lists.
Sets would also have done, but we also want to each edge to have a path as a witness.

Moreover, as we will mostly be adding edges to the graph,
we use a mutable array.
If we want to use any of the library
functions, we can convert our representation by \ensuremath{\Varid{fmap}\;\Varid{\Conid{Map}.keys}\mathbin{\circ}\Varid{freeze}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{16}{@{}>{\hspre}l<{\hspost}@{}}%
\column{28}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Graph}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Array}\;{}\<[28]%
\>[28]{}\Conid{Vertex}\;[\mskip1.5mu \Conid{Vertex}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{MGraph}{}\<[16]%
\>[16]{}\mathrel{=}\Conid{Array}\;{}\<[28]%
\>[28]{}\Conid{Vertex}\;(\Conid{\Conid{Map}.Map}\;\Conid{Vertex}\;\Conid{Path}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{MMGraph}\;\Varid{s}\mathrel{=}\Conid{STArray}\;\Varid{s}\;\Conid{Vertex}\;(\Conid{\Conid{Map}.Map}\;\Conid{Vertex}\;\Conid{Path}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{singleStep}\mathbin{::}(\Conid{Vertex}\to \Conid{Vertex}\to \Conid{PathStep})\to \Conid{Edge}\to \Conid{EdgePath}{}\<[E]%
\\
\>[B]{}\Varid{singleStep}\;\Varid{f}\;\Varid{e}\mathord{@}(\Varid{s},\Varid{t})\mathrel{=}(\Varid{e},[\mskip1.5mu \Varid{f}\;\Varid{s}\;\Varid{t}\mskip1.5mu]){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

We can add an edge to a graph, or remove it. These functions return
whether they did something (resp. addition or removal) or not. hasEdge
only checks whether a graph contains an edge or not.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{7}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addEdge}\mathbin{::}\Conid{MMGraph}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{addEdge}\;\Varid{graph}\;((\Varid{s},\Varid{t}),\Varid{p}){}\<[E]%
\\
\>[B]{}\mathrel{=}\mathbf{do}\;\Varid{m}\leftarrow \Varid{readArray}\;\Varid{graph}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\mathbf{let}\;\Varid{b}\mathrel{=}\neg \;(\Varid{\Conid{Map}.member}\;\Varid{t}\;\Varid{m}){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{when}\;\Varid{b}\;(\Varid{writeArray}\;\Varid{graph}\;\Varid{s}\;(\Varid{\Conid{Map}.insert}\;\Varid{t}\;\Varid{p}\;\Varid{m})){}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{return}\;\Varid{b}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hasEdge}\mathbin{::}\Conid{MMGraph}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;\Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{hasEdge}\;\Varid{graph}\;((\Varid{s},\Varid{t}),\anonymous ){}\<[E]%
\\
\>[B]{}\mathrel{=}\mathbf{do}\;\Varid{m}\leftarrow \Varid{readArray}\;\Varid{graph}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\hsindent{7}{}\<[7]%
\>[7]{}\Varid{return}\;(\Varid{\Conid{Map}.member}\;\Varid{t}\;\Varid{m}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The first step is to assign a number to all attributes, and a
different one to all attribute occurrences. We create an array mapping
the numbers to the information about the attribute occurrences
(\ensuremath{\Varid{ruleTable}}), so we can look up this information in $O(1)$ time. We
also build mappings from attributes to their occurrences (\ensuremath{\Varid{tdsToTdp}})
and vice versa (\ensuremath{\Varid{tdpToTds}}). \ensuremath{\Conid{LMH}} indicates the division of the
attributes - an element \ensuremath{(\Varid{l},\Varid{m},\Varid{h})\in \Conid{LMH}} means that vertices \ensuremath{\Varid{i},\Varid{l}\leq \Varid{i}\leq \Varid{h}} are attributes of the same nonterminal, with vertices \ensuremath{\Varid{j},\Varid{l}\leq \Varid{j}\mathbin{<}\Varid{m}} being inherited and \ensuremath{\Varid{k},\Varid{m}\leq \Varid{k}\leq \Varid{h}} being synthesized
attributes.

See the \ensuremath{\Conid{\Conid{SequentialTypes}.Info}} and \ensuremath{\Conid{\Conid{SequentialTypes}.LMH}}

Then we collect the direct dependencies, using the integer
representations. This list of tuples (edges in the dependency graph)
all information that is collected is passed to a function that will
compute the interfaces and visit sub-sequences. We cannot do this
computation in AG, because mutable arrays require the ST monad, which
cannot be used inside AG.

Now we can build a graph for attributes, and a graph for ao's, and add
the direct dependencies to the ao graph. Like Pennings we will call
the attribte graph Tds (transitive dependencies of symbols), and the
ao-graph Tdp (transitive dependencies of productions). Unlike him, we
will have only one Tds and one Tdp graph. In \ensuremath{\Conid{STGraph}}, we can lookup
outgoing edges in \ensuremath{\Conid{O}\;(\mathrm{1})} time, but looking up incoming edges will take
\ensuremath{\Conid{O}\;(\Varid{e})} time, where \ensuremath{\Varid{e}} is the number of edges in the graph. As we will
be doing this quite often it is worthwhile to keep both Tdp and its
transposed version. The computation will involve both Tds and Tdp. It
treats specially. TODO elaborate on that.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{type}\;\Conid{Tdp}\;\Varid{s}\mathrel{=}(\Conid{MMGraph}\;\Varid{s},\Conid{MMGraph}\;\Varid{s}){}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Tds}\;\Varid{s}\mathrel{=}\Conid{MMGraph}\;\Varid{s}{}\<[E]%
\\
\>[B]{}\mathbf{type}\;\Conid{Comp}\;\Varid{s}\mathrel{=}(\Conid{Tds}\;\Varid{s},\Conid{Tdp}\;\Varid{s}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generating IDS}

As we insert edges into Tdp we keep it transitively closed, so every
time we add the edge $(s,t)$ to V, we also add the edges
$\{ (r,t) | (r,s) \in V \}$ and
$\{ (s,u) | (t,u) \in V \}$.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{32}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{54}{@{}>{\hspre}l<{\hspost}@{}}%
\column{65}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{insertTdp}\mathbin{::}\Conid{Info}\to \Conid{Comp}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;(){}\<[E]%
\\
\>[B]{}\Varid{insertTdp}\;\Varid{info}\;\Varid{comp}\mathord{@}(\anonymous ,(\Varid{tdpN},\Varid{tdpT}))\;\Varid{e}\mathord{@}((\Varid{s},\Varid{t}),\Varid{ee}){}\<[65]%
\>[65]{}\mbox{\onelinecomment  how to insert an edge (s,t):}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{do}\;\Varid{b}\leftarrow \Varid{hasEdge}\;\Varid{tdpN}\;\Varid{e}{}\<[65]%
\>[65]{}\mbox{\onelinecomment  if it's not yet present}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{unless}\;\Varid{b}\;{}\<[E]%
\\
\>[8]{}\hsindent{7}{}\<[15]%
\>[15]{}(\mathbf{do}\;{}\<[20]%
\>[20]{}\Varid{rs}\leftarrow \Varid{readArray}\;\Varid{tdpT}\;\Varid{s}{}\<[65]%
\>[65]{}\mbox{\onelinecomment  find all sources r for an edge to s}{}\<[E]%
\\
\>[20]{}\Varid{us}\leftarrow \Varid{readArray}\;\Varid{tdpN}\;\Varid{t}{}\<[65]%
\>[65]{}\mbox{\onelinecomment  find all targets u for an edge from t}{}\<[E]%
\\
\>[20]{}\mathbf{let}\;\Varid{edges}\mathrel{=}\Varid{e}\mathbin{:}[\mskip1.5mu ((\Varid{r},\Varid{t}),\Varid{er}\plus \Varid{ee}{}\<[54]%
\>[54]{})\mid (\Varid{r},\Varid{er})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{rs}\mskip1.5mu]{}\<[E]%
\\
\>[20]{}\hsindent{12}{}\<[32]%
\>[32]{}\plus [\mskip1.5mu ((\Varid{s},\Varid{u}),{}\<[48]%
\>[48]{}\Varid{ee}\plus \Varid{eu})\mid (\Varid{u},\Varid{eu})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{us}\mskip1.5mu]{}\<[E]%
\\
\>[20]{}\hsindent{12}{}\<[32]%
\>[32]{}\plus [\mskip1.5mu ((\Varid{r},\Varid{u}),\Varid{er}\plus \Varid{ee}\plus \Varid{eu})\mid (\Varid{r},\Varid{er})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{rs},(\Varid{u},\Varid{eu})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{us}\mskip1.5mu]{}\<[E]%
\\
\>[20]{}\Varid{mapM\char95 }\;(\Varid{addTdpEdge}\;\Varid{info}\;\Varid{comp})\;\Varid{edges}{}\<[65]%
\>[65]{}\mbox{\onelinecomment  and add all of them, without having to bother about transitive closure anymore}{}\<[E]%
\\
\>[8]{}\hsindent{7}{}\<[15]%
\>[15]{}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Edges in \ensuremath{\Conid{Tdp}} can induce edges in \ensuremath{\Conid{Tds}}, so whenever we add
an edge, we also add the induced edge if necessary

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{12}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{61}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{addTdpEdge}\mathbin{::}\Conid{Info}\to \Conid{Comp}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;(){}\<[61]%
\>[61]{}\mbox{\onelinecomment  how to add an edge (s,t) when not having to bother about the transitive closure:}{}\<[E]%
\\
\>[B]{}\Varid{addTdpEdge}\;\Varid{info}\;\Varid{comp}\mathord{@}(\anonymous ,(\Varid{tdpN},\Varid{tdpT}))\;\Varid{e}\mathord{@}((\Varid{s},\Varid{t}),\Varid{ee}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{do}\;\Varid{b}\leftarrow \Varid{addEdge}\;\Varid{tdpN}\;\Varid{e}{}\<[61]%
\>[61]{}\mbox{\onelinecomment  add it to the normal graph}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{when}\;\Varid{b}\;{}\<[61]%
\>[61]{}\mbox{\onelinecomment  if it was a new edge}{}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{}(\mathbf{do}\;{}\<[17]%
\>[17]{}\Varid{addEdge}\;\Varid{tdpT}\;((\Varid{t},\Varid{s}),\Varid{ee}){}\<[61]%
\>[61]{}\mbox{\onelinecomment    also add it to the transposed graph}{}\<[E]%
\\
\>[17]{}\mathbf{let}\;{}\<[22]%
\>[22]{}\Varid{u}\mathrel{=}\Varid{tdpToTds}\;\Varid{info}\mathbin{!}\Varid{s}{}\<[61]%
\>[61]{}\mbox{\onelinecomment    find the corresponding attributes...}{}\<[E]%
\\
\>[22]{}\Varid{v}\mathrel{=}\Varid{tdpToTds}\;\Varid{info}\mathbin{!}\Varid{t}{}\<[E]%
\\
\>[22]{}\Varid{nonlocal}\mathrel{=}\Varid{u}\not\equiv \mathbin{-}\mathrm{1}\mathrel{\wedge}\Varid{v}\not\equiv \mathbin{-}\mathrm{1}{}\<[E]%
\\
\>[22]{}\Varid{equalfield}\mathrel{=}\Varid{isEqualField}\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{s})\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{t}){}\<[E]%
\\
\>[17]{}\Varid{when}\;(\Varid{nonlocal}\mathrel{\wedge}\Varid{equalfield})\;{}\<[61]%
\>[61]{}\mbox{\onelinecomment  ...and when necessary...}{}\<[E]%
\\
\>[17]{}\hsindent{5}{}\<[22]%
\>[22]{}(\Varid{insertTds}\;\Varid{info}\;\Varid{comp}\;((\Varid{u},\Varid{v}),\Varid{ee})){}\<[61]%
\>[61]{}\mbox{\onelinecomment  ...insert it to the Tds graph}{}\<[E]%
\\
\>[8]{}\hsindent{4}{}\<[12]%
\>[12]{}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Inserting edges into \ensuremath{\Conid{Tds}} will insert edges between the occurrences
of the attributes into \ensuremath{\Conid{Tdp}}.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{83}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{insertTds}\mathbin{::}\Conid{Info}\to \Conid{Comp}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;(){}\<[E]%
\\
\>[B]{}\Varid{insertTds}\;\Varid{info}\;\Varid{comp}\mathord{@}(\Varid{tds},\anonymous )\;\Varid{e}\mathord{@}((\Varid{u},\Varid{v}),\Varid{ee}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}{}\<[3E]%
\>[6]{}\mathbf{do}\;\Varid{b}\leftarrow \Varid{addEdge}\;\Varid{tds}\;\Varid{e}{}\<[E]%
\\
\>[6]{}\hsindent{3}{}\<[9]%
\>[9]{}\Varid{when}\;\Varid{b}\;{}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}(\Varid{mapM\char95 }\;(\Varid{insertTdp}\;\Varid{info}\;\Varid{comp})\;[\mskip1.5mu ((\Varid{s},\Varid{t}),[\mskip1.5mu \Conid{AttrStep}\;\Varid{u}\;\Varid{v}\mskip1.5mu]){}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{}\mid \Varid{s}\leftarrow \Varid{tdsToTdp}\;\Varid{info}\mathbin{!}\Varid{u}{}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{},\neg \;(\Varid{getIsIn}\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{s})){}\<[83]%
\>[83]{}\mbox{\onelinecomment  inherited at LHS, or synthesized at RHS}{}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{},\Varid{t}\leftarrow \Varid{tdsToTdp}\;\Varid{info}\mathbin{!}\Varid{v}{}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{},\Varid{getIsIn}\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{t}){}\<[83]%
\>[83]{}\mbox{\onelinecomment  synthesized at LHS, or inherited at RHS}{}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{},\Varid{isEqualField}\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{s})\;(\Varid{ruleTable}\;\Varid{info}\mathbin{!}\Varid{t}){}\<[E]%
\\
\>[14]{}\hsindent{29}{}\<[43]%
\>[43]{}\mskip1.5mu]{}\<[E]%
\\
\>[9]{}\hsindent{5}{}\<[14]%
\>[14]{}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

If we add the direct dependencies to the Tdp graph in the way above, the
Tds graph is filled with IDS.
Below is a way to only build up the Tdp graph, without reflect the changes in the Tds graph.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{15}{@{}>{\hspre}c<{\hspost}@{}}%
\column{15E}{@{}l@{}}%
\column{17}{@{}>{\hspre}c<{\hspost}@{}}%
\column{17E}{@{}l@{}}%
\column{19}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{56}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{simpleInsert}\mathbin{::}\Conid{Tdp}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;(){}\<[E]%
\\
\>[B]{}\Varid{simpleInsert}\;\Varid{tdp}\mathord{@}(\Varid{tdpN},\Varid{tdpT})\;\Varid{e}\mathord{@}((\Varid{s},\Varid{t}),\Varid{ee}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{do}\;\Varid{b}\leftarrow \Varid{hasEdge}\;\Varid{tdpT}\;((\Varid{t},\Varid{s}),\bot ){}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{unless}\;\Varid{b}\;(\mathbf{do}\;{}\<[22]%
\>[22]{}\Varid{rs}\leftarrow \Varid{readArray}\;\Varid{tdpT}\;\Varid{s}{}\<[E]%
\\
\>[22]{}\Varid{us}\leftarrow \Varid{readArray}\;\Varid{tdpN}\;\Varid{t}{}\<[E]%
\\
\>[22]{}\mathbf{let}\;\Varid{edges}\mathrel{=}\Varid{e}\mathbin{:}[\mskip1.5mu ((\Varid{r},\Varid{t}),\Varid{er}\plus \Varid{ee}{}\<[56]%
\>[56]{})\mid (\Varid{r},\Varid{er})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{rs}\mskip1.5mu]{}\<[E]%
\\
\>[22]{}\hsindent{12}{}\<[34]%
\>[34]{}\plus [\mskip1.5mu ((\Varid{s},\Varid{u}),{}\<[50]%
\>[50]{}\Varid{ee}\plus \Varid{eu})\mid (\Varid{u},\Varid{eu})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{us}\mskip1.5mu]{}\<[E]%
\\
\>[22]{}\hsindent{12}{}\<[34]%
\>[34]{}\plus [\mskip1.5mu ((\Varid{r},\Varid{u}),\Varid{er}\plus \Varid{ee}\plus \Varid{eu})\mid (\Varid{r},\Varid{er})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{rs},(\Varid{u},\Varid{eu})\leftarrow \Varid{\Conid{Map}.toList}\;\Varid{us}\mskip1.5mu]{}\<[E]%
\\
\>[22]{}\Varid{mapM\char95 }\;(\Varid{addSimpleEdge}\;\Varid{tdp})\;\Varid{edges}{}\<[E]%
\\
\>[8]{}\hsindent{9}{}\<[17]%
\>[17]{}){}\<[17E]%
\\[\blanklineskip]%
\>[B]{}\Varid{addSimpleEdge}\mathbin{::}\Conid{Tdp}\;\Varid{s}\to \Conid{EdgePath}\to \Conid{ST}\;\Varid{s}\;(){}\<[E]%
\\
\>[B]{}\Varid{addSimpleEdge}\;(\Varid{tdpN},\Varid{tdpT})\;\Varid{e}\mathord{@}((\Varid{s},\Varid{t}),\Varid{ee}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{do}\;\Varid{b}\leftarrow \Varid{addEdge}\;\Varid{tdpN}\;\Varid{e}{}\<[E]%
\\
\>[3]{}\hsindent{5}{}\<[8]%
\>[8]{}\Varid{when}\;\Varid{b}\;(\mathbf{do}\;\Varid{addEdge}\;\Varid{tdpT}\;((\Varid{t},\Varid{s}),\Varid{ee}){}\<[E]%
\\
\>[8]{}\hsindent{11}{}\<[19]%
\>[19]{}\Varid{return}\;(){}\<[E]%
\\
\>[8]{}\hsindent{7}{}\<[15]%
\>[15]{}){}\<[15E]%
\ColumnHook
\end{hscode}\resethooks


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Interfaces}

In absence of cycles we can find the interfaces. We only take
attributes that are used.

When an attribute has no incoming edges it can be computed. As the
emphasis is on incoming edges, we will work with the transposed Tds
graph. The funtion \ensuremath{\Varid{used}} indicates which vertices are included in the
interfaces.

See modules Interfaces and InterfacesRules for more information.


\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}c<{\hspost}@{}}%
\column{3E}{@{}l@{}}%
\column{6}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{makeInterfaces}\mathbin{::}\Conid{Info}\to \Conid{Graph}\to \Conid{T\char95 IRoot}{}\<[E]%
\\
\>[B]{}\Varid{makeInterfaces}\;\Varid{info}\;\Varid{tds}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}{}\<[3E]%
\>[6]{}\mathbf{let}\;\Varid{interslist}\mathrel{=}\Varid{reverse}\mathbin{\circ}\Varid{makeInterface}\;\Varid{tds}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\Varid{mkSegments}\mathrel{=}\Varid{foldr}\;(:_{Segments}\mathbin{\circ}\Varid{uncurry}\;\Varid{sem\char95 Segment\char95 Segment})\;[]_{Segments}\mathbin{\circ}\Varid{interslist}{}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\Varid{mkInter}\;((\Varid{nt},\Varid{cons}),\Varid{lmh})\mathrel{=}sem_{Interface}\;\Varid{nt}\;\Varid{cons}\;(\Varid{mkSegments}\;\Varid{lmh}){}\<[E]%
\\
\>[6]{}\hsindent{4}{}\<[10]%
\>[10]{}\Varid{inters}\mathrel{=}\Varid{foldr}\;(:_{Interfaces}\mathbin{\circ}\Varid{mkInter})\;[]_{Interfaces}\;(\Varid{zip}\;(\Varid{nonts}\;\Varid{info})\;(\Varid{lmh}\;\Varid{info})){}\<[E]%
\\
\>[6]{}\mathbf{in}\;sem_{IRoot}\;\Varid{inters}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

The sinks of a graph are those vertices that have no outgoing
edges. We define a function that determines whether a vertex is a sink
if a set \ensuremath{\Varid{del}} of vertices had been removed from the graph. This means
that the attribute can be computed if all attributes in \ensuremath{\Varid{del}} have
been computed.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{isSink}\mathbin{::}\Conid{Graph}\to [\mskip1.5mu \Conid{Vertex}\mskip1.5mu]\to \Conid{Vertex}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{isSink}\;\Varid{graph}\;\Varid{del}\;\Varid{v}\mathrel{=}\Varid{null}\;(\Varid{graph}\mathbin{!}\Varid{v}\mathbin{\char92 \char92 }\Varid{del}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Now we can make interfaces by taking inherited sinks and synthesized
sinks alternatively. If there are no synthesized attributes at all,
generate an interface with one visit computing nothing.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{24}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{makeInterface}\mathbin{::}\Conid{Graph}\to [\mskip1.5mu \Conid{Vertex}\mskip1.5mu]\to \Conid{LMH}\to [\mskip1.5mu ([\mskip1.5mu \Conid{Vertex}\mskip1.5mu],[\mskip1.5mu \Conid{Vertex}\mskip1.5mu])\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{makeInterface}\;\Varid{tds}\;\Varid{del}\;(\Varid{l},\Varid{m},\Varid{h}){}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{m}\mathbin{>}\Varid{h}\mathrel{=}[\mskip1.5mu ([\mskip1.5mu \mskip1.5mu],[\mskip1.5mu \mskip1.5mu])\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mid \Varid{otherwise}\mathrel{=}\mathbf{let}\;{}\<[22]%
\>[22]{}\Varid{syn}\mathrel{=}\Varid{filter}\;(\Varid{isSink}\;\Varid{tds}\;\Varid{del})\;([\mskip1.5mu \Varid{m}\mathinner{\ldotp\ldotp}\Varid{h}\mskip1.5mu]\mathbin{\char92 \char92 }\Varid{del}){}\<[E]%
\\
\>[22]{}\Varid{del'}\mathrel{=}\Varid{del}\plus \Varid{syn}{}\<[E]%
\\
\>[22]{}\Varid{inh}\mathrel{=}\Varid{filter}\;(\Varid{isSink}\;\Varid{tds}\;\Varid{del'})\;([\mskip1.5mu \Varid{l}\mathinner{\ldotp\ldotp}(\Varid{m}\mathbin{-}\mathrm{1})\mskip1.5mu]\mathbin{\char92 \char92 }\Varid{del'}){}\<[E]%
\\
\>[22]{}\Varid{del''}\mathrel{=}\Varid{del'}\plus \Varid{inh}{}\<[E]%
\\
\>[22]{}\Varid{rest}\mathrel{=}\Varid{makeInterface}\;\Varid{tds}\;\Varid{del''}\;(\Varid{l},\Varid{m},\Varid{h}){}\<[E]%
\\
\>[3]{}\hsindent{14}{}\<[17]%
\>[17]{}\mathbf{in}\;\mathbf{if}\;{}\<[24]%
\>[24]{}\Varid{null}\;\Varid{inh}\mathrel{\wedge}\Varid{null}\;\Varid{syn}{}\<[E]%
\\
\>[24]{}\mathbf{then}\;[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[24]{}\mathbf{else}\;(\Varid{inh},\Varid{syn})\mathbin{:}\Varid{rest}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Detecting of cycles}

We only want to return s2i edges.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{46}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{findCycles}\mathbin{::}\Conid{Info}\to \Conid{MGraph}\to [\mskip1.5mu \Conid{EdgePaths}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{findCycles}\;\Varid{info}\;\Varid{tds}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu ((\Varid{u},\Varid{v}),\Varid{p1},\Varid{p2}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid (\Varid{l},\Varid{m},\Varid{h})\leftarrow \Varid{lmh}\;\Varid{info}{}\<[46]%
\>[46]{}\mbox{\onelinecomment  for every nonterminal: [l..m-1] are inherited, [m..h] are synthesized}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{v}\leftarrow [\mskip1.5mu \Varid{m}\mathinner{\ldotp\ldotp}\Varid{h}\mskip1.5mu]{}\<[46]%
\>[46]{}\mbox{\onelinecomment  for every synthesized attribute}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},(\Varid{u},\Varid{p1})\leftarrow \Varid{\Conid{Map}.toList}\;(\Varid{tds}\mathbin{!}\Varid{v}){}\<[46]%
\>[46]{}\mbox{\onelinecomment  find dependent attributes...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{l}\leq \Varid{u},\Varid{u}\mathbin{<}\Varid{m}{}\<[46]%
\>[46]{}\mbox{\onelinecomment  ...that are inherited...}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\mathbf{let}\;\Varid{mbp2}\mathrel{=}\Varid{\Conid{Map}.lookup}\;\Varid{v}\;(\Varid{tds}\mathbin{!}\Varid{u}){}\<[46]%
\>[46]{}\mbox{\onelinecomment  ...and have a cycle back}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{isJust}\;\Varid{mbp2}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\mathbf{let}\;\Varid{p2}\mathrel{=}\Varid{fromJust}\;\Varid{mbp2}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{findLocCycles}\mathbin{::}\Conid{MGraph}\to [\mskip1.5mu \Conid{EdgePath}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{findLocCycles}\;\Varid{tdp}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{let}\;(\Varid{low},\Varid{high})\mathrel{=}\Varid{bounds}\;\Varid{tdp}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{in}\;{}\<[9]%
\>[9]{}[\mskip1.5mu ((\Varid{u},\Varid{u}),\Varid{p}){}\<[E]%
\\
\>[9]{}\mid \Varid{u}\leftarrow [\mskip1.5mu \Varid{low}\mathinner{\ldotp\ldotp}\Varid{high}\mskip1.5mu]{}\<[E]%
\\
\>[9]{},(\Varid{v},\Varid{p})\leftarrow \Varid{\Conid{Map}.toList}\;(\Varid{tdp}\mathbin{!}\Varid{u}){}\<[E]%
\\
\>[9]{},\Varid{v}\equiv \Varid{u}{}\<[E]%
\\
\>[9]{}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{findInstCycles}\mathbin{::}[\mskip1.5mu \Conid{Edge}\mskip1.5mu]\to \Conid{MGraph}\to [\mskip1.5mu \Conid{EdgePath}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{findInstCycles}\;\Varid{instToSynEdges}\;\Varid{tdp}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}[\mskip1.5mu ((\Varid{i},\Varid{s}),\Varid{fromJust}\;\Varid{mbp}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mid (\Varid{i},\Varid{s})\leftarrow \Varid{instToSynEdges}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\mathbf{let}\;\Varid{mbp}\mathrel{=}\Varid{\Conid{Map}.lookup}\;\Varid{i}\;(\Varid{tdp}\mathbin{!}\Varid{s}){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{},\Varid{isJust}\;\Varid{mbp}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mskip1.5mu]{}\<[E]%
\ColumnHook
\end{hscode}\resethooks



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tying it together}

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{5}{@{}>{\hspre}l<{\hspost}@{}}%
\column{8}{@{}>{\hspre}l<{\hspost}@{}}%
\column{9}{@{}>{\hspre}l<{\hspost}@{}}%
\column{10}{@{}>{\hspre}l<{\hspost}@{}}%
\column{11}{@{}>{\hspre}l<{\hspost}@{}}%
\column{13}{@{}>{\hspre}l<{\hspost}@{}}%
\column{14}{@{}>{\hspre}l<{\hspost}@{}}%
\column{17}{@{}>{\hspre}l<{\hspost}@{}}%
\column{20}{@{}>{\hspre}l<{\hspost}@{}}%
\column{22}{@{}>{\hspre}l<{\hspost}@{}}%
\column{25}{@{}>{\hspre}l<{\hspost}@{}}%
\column{26}{@{}>{\hspre}l<{\hspost}@{}}%
\column{27}{@{}>{\hspre}l<{\hspost}@{}}%
\column{33}{@{}>{\hspre}l<{\hspost}@{}}%
\column{34}{@{}>{\hspre}l<{\hspost}@{}}%
\column{35}{@{}>{\hspre}l<{\hspost}@{}}%
\column{37}{@{}>{\hspre}l<{\hspost}@{}}%
\column{38}{@{}>{\hspre}l<{\hspost}@{}}%
\column{39}{@{}>{\hspre}l<{\hspost}@{}}%
\column{40}{@{}>{\hspre}l<{\hspost}@{}}%
\column{43}{@{}>{\hspre}l<{\hspost}@{}}%
\column{47}{@{}>{\hspre}l<{\hspost}@{}}%
\column{48}{@{}>{\hspre}l<{\hspost}@{}}%
\column{50}{@{}>{\hspre}l<{\hspost}@{}}%
\column{51}{@{}>{\hspre}l<{\hspost}@{}}%
\column{52}{@{}>{\hspre}l<{\hspost}@{}}%
\column{59}{@{}>{\hspre}l<{\hspost}@{}}%
\column{60}{@{}>{\hspre}l<{\hspost}@{}}%
\column{63}{@{}>{\hspre}l<{\hspost}@{}}%
\column{69}{@{}>{\hspre}l<{\hspost}@{}}%
\column{71}{@{}>{\hspre}l<{\hspost}@{}}%
\column{80}{@{}>{\hspre}l<{\hspost}@{}}%
\column{92}{@{}>{\hspre}l<{\hspost}@{}}%
\column{104}{@{}>{\hspre}l<{\hspost}@{}}%
\column{108}{@{}>{\hspre}l<{\hspost}@{}}%
\column{119}{@{}>{\hspre}l<{\hspost}@{}}%
\column{123}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{generateVisits}\mathbin{::}\Conid{Info}\to \Conid{MGraph}\to \Conid{MGraph}\to [\mskip1.5mu \Conid{Edge}\mskip1.5mu]\to (\Conid{CInterfaceMap},\Conid{CVisitsMap},[\mskip1.5mu \Conid{Edge}\mskip1.5mu]){}\<[E]%
\\
\>[B]{}\Varid{generateVisits}\;\Varid{info}\;\Varid{tds}\;\Varid{tdp}\;\Varid{dpr}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\mathbf{let}\;{}\<[10]%
\>[10]{}\Varid{inters}\mathrel{=}\Varid{makeInterfaces}\;\Varid{info}\;(\Varid{fmap}\;\Varid{\Conid{Map}.keys}\;\Varid{tds}){}\<[E]%
\\
\>[10]{}\Varid{inhs}\mathrel{=}\Conid{Inh\char95 IRoot}\;\{\mskip1.5mu \Varid{info\char95 Inh\char95 IRoot}\mathrel{=}\Varid{info}{}\<[E]%
\\
\>[10]{}\hsindent{16}{}\<[26]%
\>[26]{},\Varid{tdp\char95 Inh\char95 IRoot}{}\<[43]%
\>[43]{}\mathrel{=}\Varid{fmap}\;\Varid{\Conid{Map}.keys}\;\Varid{tdp}{}\<[E]%
\\
\>[10]{}\hsindent{16}{}\<[26]%
\>[26]{},\Varid{dpr\char95 Inh\char95 IRoot}{}\<[43]%
\>[43]{}\mathrel{=}\Varid{dpr}{}\<[E]%
\\
\>[10]{}\hsindent{16}{}\<[26]%
\>[26]{}\mskip1.5mu\}{}\<[E]%
\\
\>[10]{}\Varid{iroot}\mathrel{=}\Varid{wrap\char95 IRoot}\;\Varid{inters}\;\Varid{inhs}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{in}\;(\Varid{inters\char95 Syn\char95 IRoot}\;\Varid{iroot},\Varid{visits\char95 Syn\char95 IRoot}\;\Varid{iroot},\Varid{edp\char95 Syn\char95 IRoot}\;\Varid{iroot}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{reportLocalCycle}\mathbin{::}\Conid{MGraph}\to [\mskip1.5mu \Conid{EdgePath}\mskip1.5mu]\to [\mskip1.5mu [\mskip1.5mu \Conid{Vertex}\mskip1.5mu]\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{reportLocalCycle}\;\Varid{tds}\;\Varid{cyc}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{fst}\;(\Varid{foldr}\;\Varid{f}\;([\mskip1.5mu \mskip1.5mu],\Varid{\Conid{Set}.empty})\;(\Varid{map}\;(\Varid{edgePathToEdgeRoute}\;\Varid{tds})\;\Varid{cyc})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{f}\;((\Varid{x},\anonymous ),\Varid{p})\;\Varid{res}\mathord{@}(\Varid{paths},\Varid{syms})\mid \Varid{\Conid{Set}.member}\;\Varid{x}\;\Varid{syms}\mathrel{=}\Varid{res}{}\<[69]%
\>[69]{}\mbox{\onelinecomment  don't report a cyclic vertex if it appears on a path of an earlier reported one}{}\<[E]%
\\
\>[5]{}\hsindent{35}{}\<[40]%
\>[40]{}\mid \Varid{otherwise}{}\<[60]%
\>[60]{}\mathrel{=}(\Varid{p}\mathbin{:}\Varid{paths},\Varid{\Conid{Set}.union}\;\Varid{syms}\;(\Varid{\Conid{Set}.fromList}\;\Varid{p})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{reportCycle}\mathbin{::}\Conid{Info}\to \Conid{MGraph}\to [\mskip1.5mu \Conid{EdgePaths}\mskip1.5mu]\to [\mskip1.5mu \Conid{EdgeRoutes}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{reportCycle}\;\Varid{info}\;\Varid{tds}\;\Varid{cyc}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{fst}\;(\Varid{foldr}\;\Varid{f}\;([\mskip1.5mu \mskip1.5mu],\Varid{\Conid{Set}.empty})\;(\Varid{map}\;(\Varid{edgePathsToEdgeRoutes}\;\Varid{tds})\;\Varid{cyc})){}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}\mathbf{where}\;\Varid{f}\;\Varid{epp}\mathord{@}((\Varid{x},\Varid{y}),\Varid{p1},\Varid{p2})\;\Varid{res}\mathord{@}(\Varid{paths},\Varid{syms})\mid \Varid{\Conid{Set}.member}\;\Varid{x}\;\Varid{syms}\mathrel{\wedge}{}\<[E]%
\\
\>[5]{}\hsindent{45}{}\<[50]%
\>[50]{}\Varid{\Conid{Set}.member}\;\Varid{y}\;\Varid{syms}{}\<[71]%
\>[71]{}\mathrel{=}\Varid{res}{}\<[80]%
\>[80]{}\mbox{\onelinecomment  don't report mutually dependent vertices if both appear on paths reported earlier}{}\<[E]%
\\
\>[5]{}\hsindent{43}{}\<[48]%
\>[48]{}\mid \Varid{otherwise}{}\<[71]%
\>[71]{}\mathrel{=}(\Varid{epp}\mathbin{:}\Varid{paths},\Varid{\Conid{Set}.union}\;\Varid{syms}\;(\Varid{\Conid{Set}.fromList}\;(\Varid{map}\;\Varid{tdp2tds}\;(\Varid{p1}\plus \Varid{p2})))){}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{tdp2tds}\;(\mathbin{-}\mathrm{2})\mathrel{=}\mathbin{-}\mathrm{2}{}\<[E]%
\\
\>[5]{}\hsindent{6}{}\<[11]%
\>[11]{}\Varid{tdp2tds}\;\Varid{v}\mathrel{=}\Varid{tdpToTds}\;\Varid{info}\mathbin{!}\Varid{v}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{edgePathsToEdgeRoutes}\mathbin{::}\Conid{MGraph}\to \Conid{EdgePaths}\to \Conid{EdgeRoutes}{}\<[E]%
\\
\>[B]{}\Varid{edgePathsToEdgeRoutes}\;\Varid{tds}\;(\Varid{e},\Varid{p1},\Varid{p2})\mathrel{=}(\Varid{e},\Varid{pathToRoute}\;\Varid{tds}\;\Varid{p1},\Varid{pathToRoute}\;\Varid{tds}\;\Varid{p2}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{edgePathToEdgeRoute}\mathbin{::}\Conid{MGraph}\to \Conid{EdgePath}\to \Conid{EdgeRoute}{}\<[E]%
\\
\>[B]{}\Varid{edgePathToEdgeRoute}\;\Varid{tds}\;(\Varid{e},\Varid{p})\mathrel{=}(\Varid{e},\Varid{pathToRoute}\;\Varid{tds}\;\Varid{p}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{pathToRoute}\mathbin{::}\Conid{MGraph}\to \Conid{Path}\to \Conid{Route}{}\<[E]%
\\
\>[B]{}\Varid{pathToRoute}\;\Varid{tds}\;\Varid{p}\mathrel{=}\Varid{convertPath}\;(\Varid{expandAll}\;\Varid{p}){}\<[E]%
\\
\>[B]{}\mathbf{where}\;\Varid{expandAll}\mathbin{::}\Conid{Path}\to \Conid{Path}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandAll}\;\Varid{p}\mid \Varid{hasAttrStep}\;\Varid{p}{}\<[37]%
\>[37]{}\mathrel{=}\Varid{expandAll}\;(\Varid{expandOne}\;\Varid{p}){}\<[E]%
\\
\>[8]{}\hsindent{12}{}\<[20]%
\>[20]{}\mid \Varid{otherwise}{}\<[37]%
\>[37]{}\mathrel{=}\Varid{p}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandOne}\mathbin{::}\Conid{Path}\to \Conid{Path}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandOne}\;\Varid{p}\mathrel{=}\Varid{shortcut}\;(\Varid{concatMap}\;\Varid{expandStep}\;\Varid{p}){}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandStep}\mathbin{::}\Conid{PathStep}\to \Conid{Path}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandStep}\;(\Conid{AttrStep}\;\Varid{u}\;\Varid{v})\mathrel{=}\Varid{fromJust}\;(\Varid{\Conid{Map}.lookup}\;\Varid{v}\;(\Varid{tds}\mathbin{!}\Varid{u})){}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{expandStep}\;\Varid{x}{}\<[34]%
\>[34]{}\mathrel{=}[\mskip1.5mu \Varid{x}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{convertPath}\mathbin{::}\Conid{Path}\to \Conid{Route}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{convertPath}\;\Varid{p}\mathrel{=}\Varid{concatMap}\;\Varid{convertStep}\;\Varid{p}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{convertStep}\mathbin{::}\Conid{PathStep}\to \Conid{Route}{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{convertStep}\;(\Conid{AtOcStep}\;\Varid{s}\;\Varid{t})\mathrel{=}[\mskip1.5mu \Varid{s},\Varid{t}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\hsindent{8}{}\<[8]%
\>[8]{}\Varid{convertStep}\;(\Conid{AttrIndu}\;\Varid{s}\;\Varid{t})\mathrel{=}[\mskip1.5mu \mathbin{-}\mathrm{2},\mathbin{-}\mathrm{2}\mskip1.5mu]{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{hasAttrStep}\mathbin{::}\Conid{Path}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{hasAttrStep}\;[\mskip1.5mu \mskip1.5mu]{}\<[33]%
\>[33]{}\mathrel{=}\Conid{False}{}\<[E]%
\\
\>[B]{}\Varid{hasAttrStep}\;(\Conid{AttrStep}\;\anonymous \;\anonymous \mathbin{:}\anonymous )\mathrel{=}\Conid{True}{}\<[E]%
\\
\>[B]{}\Varid{hasAttrStep}\;(\anonymous {}\<[27]%
\>[27]{}\mathbin{:}\Varid{xs})\mathrel{=}\Varid{hasAttrStep}\;\Varid{xs}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{shortcut}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{shortcut}\;[\mskip1.5mu \mskip1.5mu]{}\<[17]%
\>[17]{}\mathrel{=}[\mskip1.5mu \mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{shortcut}\;(\Varid{x}\mathbin{:}\Varid{xs})\mathrel{=}\Varid{x}\mathbin{:}\Varid{shortcut}\;(\Varid{removeBefore}\;\Varid{x}\;\Varid{xs}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{removeBefore}\mathbin{::}\Conid{Eq}\;\Varid{a}\Rightarrow \Varid{a}\to [\mskip1.5mu \Varid{a}\mskip1.5mu]\to [\mskip1.5mu \Varid{a}\mskip1.5mu]{}\<[E]%
\\
\>[B]{}\Varid{removeBefore}\;\Varid{x}\;\Varid{ys}\mathrel{=}\Varid{reverse}\;(\Varid{takeWhile}\;(\not\equiv \Varid{x})\;(\Varid{reverse}\;\Varid{ys})){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{isLocLoc}\mathbin{::}\Conid{Table}\;\Conid{CRule}\to \Conid{EdgePath}\to \Conid{Bool}{}\<[E]%
\\
\>[B]{}\Varid{isLocLoc}\;\Varid{rt}\;((\Varid{s},\Varid{t}),\anonymous )\mathrel{=}\Varid{isLocal}\;(\Varid{rt}\mathbin{!}\Varid{s})\mathrel{\wedge}\Varid{isLocal}\;(\Varid{rt}\mathbin{!}\Varid{t}){}\<[E]%
\\
\>[B]{}\hsindent{25}{}\<[25]%
\>[25]{}\mbox{\onelinecomment  | (isInst (rt ! s) && isInst (rt ! t))}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{computeSequential}\mathbin{::}\Conid{Info}\to [\mskip1.5mu \Conid{Edge}\mskip1.5mu]\to [\mskip1.5mu \Conid{Edge}\mskip1.5mu]\to \Conid{CycleStatus}{}\<[E]%
\\
\>[B]{}\Varid{computeSequential}\;\Varid{info}\;\Varid{dpr}\;\Varid{instToSynEdges}{}\<[E]%
\\
\>[B]{}\hsindent{3}{}\<[3]%
\>[3]{}\mathrel{=}\Varid{runST}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}(\mathbf{do}\;\mathbf{let}\;\Varid{bigBounds}{}\<[25]%
\>[25]{}\mathrel{=}\Varid{bounds}\;(\Varid{tdpToTds}\;\Varid{info}){}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}\Varid{smallBounds}\mathrel{=}\Varid{bounds}\;(\Varid{tdsToTdp}\;\Varid{info}){}\<[E]%
\\
\>[5]{}\hsindent{8}{}\<[13]%
\>[13]{}(\Varid{ll},\Varid{es})\mathrel{=}\Varid{partition}\;(\Varid{isLocLoc}\;(\Varid{ruleTable}\;\Varid{info}))\;(\Varid{map}\;(\Varid{singleStep}\;\Conid{AtOcStep})\;(\Varid{dpr}\plus \Varid{instToSynEdges})){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{tds}{}\<[14]%
\>[14]{}\leftarrow \Varid{newArray}\;\Varid{smallBounds}\;\Varid{\Conid{Map}.empty}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{tdpN}\leftarrow \Varid{newArray}\;\Varid{bigBounds}\;{}\<[38]%
\>[38]{}\Varid{\Conid{Map}.empty}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{tdpT}\leftarrow \Varid{newArray}\;\Varid{bigBounds}\;{}\<[38]%
\>[38]{}\Varid{\Conid{Map}.empty}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;\Varid{tdp}\mathrel{=}(\Varid{tdpN},\Varid{tdpT}){}\<[E]%
\\
\>[9]{}\hsindent{4}{}\<[13]%
\>[13]{}\Varid{comp}\mathrel{=}(\Varid{tds},\Varid{tdp}){}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{mapM\char95 }\;(\Varid{simpleInsert}\;\Varid{tdp})\;\Varid{ll}{}\<[92]%
\>[92]{}\mbox{\onelinecomment  insert the local dependencies}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\Varid{tdp1}\leftarrow \Varid{freeze}\;\Varid{tdpN}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{let}\;\Varid{cyc1}\mathrel{=}\Varid{findLocCycles}\;\Varid{tdp1}{}\<[E]%
\\
\>[5]{}\hsindent{4}{}\<[9]%
\>[9]{}\mathbf{if}\;{}\<[13]%
\>[13]{}\neg \;(\Varid{null}\;\Varid{cyc1}){}\<[92]%
\>[92]{}\mbox{\onelinecomment  are they cyclic?}{}\<[E]%
\\
\>[13]{}\mathbf{then}\;\mathbf{do}\;\Varid{return}\;(\Conid{LocalCycle}\;(\Varid{reportLocalCycle}\;\bot \;\Varid{cyc1})){}\<[92]%
\>[92]{}\mbox{\onelinecomment  then report an error.}{}\<[E]%
\\
\>[13]{}\mathbf{else}\;\mathbf{do}\;{}\<[22]%
\>[22]{}\Varid{mapM\char95 }\;(\Varid{insertTdp}\;\Varid{info}\;\Varid{comp})\;\Varid{es}{}\<[92]%
\>[92]{}\mbox{\onelinecomment  insert the other dependencies}{}\<[E]%
\\
\>[22]{}\Varid{tds2}\leftarrow \Varid{freeze}\;\Varid{tds}{}\<[E]%
\\
\>[22]{}\mathbf{let}\;\Varid{cyc2}\mathrel{=}\Varid{findCycles}\;\Varid{info}\;\Varid{tds2}{}\<[E]%
\\
\>[22]{}\mathbf{if}\;{}\<[26]%
\>[26]{}\neg \;(\Varid{null}\;\Varid{cyc2}){}\<[92]%
\>[92]{}\mbox{\onelinecomment  are they cyclic?}{}\<[E]%
\\
\>[26]{}\mathbf{then}\;\mathbf{do}\;{}\<[35]%
\>[35]{}\Varid{return}\;(\Conid{DirectCycle}\;(\Varid{reportCycle}\;\Varid{info}\;\Varid{tds2}\;\Varid{cyc2})){}\<[92]%
\>[92]{}\mbox{\onelinecomment  then report an error.}{}\<[E]%
\\
\>[26]{}\mathbf{else}\;\mathbf{do}\;{}\<[35]%
\>[35]{}\Varid{tdp2}\leftarrow \Varid{freeze}\;\Varid{tdpN}{}\<[E]%
\\
\>[35]{}\mathbf{let}\;\Varid{cyc4}\mathrel{=}\Varid{findInstCycles}\;\Varid{instToSynEdges}\;\Varid{tdp2}{}\<[E]%
\\
\>[35]{}\mathbf{if}\;{}\<[39]%
\>[39]{}\neg \;(\Varid{null}\;\Varid{cyc4}){}\<[E]%
\\
\>[39]{}\mathbf{then}\;\mathbf{do}\;\Varid{return}\;(\Conid{InstCycle}\;(\Varid{reportLocalCycle}\;\Varid{tds2}\;\Varid{cyc4})){}\<[108]%
\>[108]{}\mbox{\onelinecomment  then report an error.}{}\<[E]%
\\
\>[39]{}\mathbf{else}\;\mathbf{do}\;\mathbf{let}\;{}\<[52]%
\>[52]{}(\Varid{cim},\Varid{cvm},\Varid{edp})\mathrel{=}\Varid{generateVisits}\;\Varid{info}\;\Varid{tds2}\;\Varid{tdp2}\;\Varid{dpr}{}\<[E]%
\\
\>[39]{}\hsindent{8}{}\<[47]%
\>[47]{}\Varid{mapM\char95 }\;(\Varid{insertTds}\;\Varid{info}\;\Varid{comp})\;(\Varid{map}\;(\Varid{singleStep}\;\Conid{AttrIndu})\;\Varid{edp})\mbox{\onelinecomment  insert dependencies induced by visit scheduling}{}\<[E]%
\\
\>[39]{}\hsindent{8}{}\<[47]%
\>[47]{}\Varid{tds3}\leftarrow \Varid{freeze}\;\Varid{tds}{}\<[E]%
\\
\>[39]{}\hsindent{8}{}\<[47]%
\>[47]{}\mathbf{let}\;\Varid{cyc3}\mathrel{=}\Varid{findCycles}\;\Varid{info}\;\Varid{tds3}{}\<[E]%
\\
\>[39]{}\hsindent{8}{}\<[47]%
\>[47]{}\mathbf{if}\;{}\<[51]%
\>[51]{}\neg \;(\Varid{null}\;\Varid{cyc3}){}\<[104]%
\>[104]{}\mbox{\onelinecomment  are they cyclic?}{}\<[E]%
\\
\>[51]{}\mathbf{then}\;\Varid{return}\;(\Conid{InducedCycle}\;\Varid{cim}\;(\Varid{reportCycle}\;\Varid{info}\;\Varid{tds3}\;\Varid{cyc3}))\mbox{\onelinecomment  then report an error.}{}\<[E]%
\\
\>[51]{}\mathbf{else}\;\mathbf{do}\;\Varid{tdp3}\leftarrow \Varid{freeze}\;\Varid{tdpN}{}\<[E]%
\\
\>[51]{}\hsindent{8}{}\<[59]%
\>[59]{}\mathbf{let}\;\Varid{cyc5}\mathrel{=}\Varid{findInstCycles}\;\Varid{instToSynEdges}\;\Varid{tdp3}{}\<[E]%
\\
\>[51]{}\hsindent{8}{}\<[59]%
\>[59]{}\mathbf{if}\;{}\<[63]%
\>[63]{}\neg \;(\Varid{null}\;\Varid{cyc5}){}\<[E]%
\\
\>[63]{}\mathbf{then}\;\mathbf{do}\;\Varid{return}\;(\Conid{InstCycle}\;(\Varid{reportLocalCycle}\;\Varid{tds3}\;\Varid{cyc5})){}\<[123]%
\>[123]{}\mbox{\onelinecomment  then report an error.}{}\<[E]%
\\
\>[63]{}\mathbf{else}\;\mathbf{do}\;\Varid{return}\;(\Conid{CycleFree}\;\Varid{cim}\;\Varid{cvm}){}\<[119]%
\>[119]{}\mbox{\onelinecomment  otherwise we succeed.}{}\<[E]%
\\
\>[3]{}\hsindent{2}{}\<[5]%
\>[5]{}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks


\end{document}
